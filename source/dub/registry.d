/**	A package supplier using the registry server.	Copyright: Â© 2012 Matthias Dondorff	License: Subject to the terms of the MIT license, as written in the included LICENSE.txt file.	Authors: Matthias Dondorff*/module dub.registry;import dub.dependency;import dub.packagesupplier;import dub.utils;import vibecompat.core.file;import vibecompat.core.log;import vibecompat.data.json;import vibecompat.inet.url;import vibecompat.inet.urltransfer;import std.conv;import std.exception;import std.file;private const string PackagesPath = "packages";/// Client PackageSupplier using the registry available via registerVpmRegistryclass RegistryPS : PackageSupplier {	this(Url registry) { m_registryUrl = registry; }		void retrievePackage(const Path path, const string packageId, const Dependency dep) {		Json best = getBestPackage(packageId, dep);		auto url = m_registryUrl ~ Path("packages/"~packageId~"/"~best["version"].get!string~".zip");		logDebug("Found download URL: '%s'", url);		download(url, path);	}		Json getPackageDescription(const string packageId, const Dependency dep) {		return getBestPackage(packageId, dep);	}		private {		Url m_registryUrl;		Json[string] m_allMetadata;	}		private Json getMetadata(const string packageId) {		if( auto json = packageId in m_allMetadata ) 			return *json;		auto url = m_registryUrl ~ Path(PackagesPath ~ "/" ~ packageId ~ ".json");				logTrace("Downloading metadata for %s", packageId);		logTrace("Getting from %s", url);		import std.net.curl;		auto conn = HTTP();		static if( is(typeof(&conn.verifyPeer)) )			conn.verifyPeer = false;		auto jsonData = cast(string)get(url.toString(), conn);		Json json = parseJson(jsonData);		m_allMetadata[packageId] = json;		return json;	}		private Json getBestPackage(const string packageId, const Dependency dep) {		Json md = getMetadata(packageId);		Json best = null;		foreach(json; md["versions"]) {			auto cur = Version(cast(string)json["version"]);			if(dep.matches(cur) && (best == null || Version(cast(string)best["version"]) < cur))				best = json;		}		enforce(best != null, "No package candidate found for "~packageId~" "~dep.toString());		return best;	}}